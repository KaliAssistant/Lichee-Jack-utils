#!/usr/bin/env python3
import toml
import uuid
import os
from pathlib import Path
import argparse
from datetime import datetime
import shutil

CONFIG_FILE = "/root/config/licheejack.toml"
NM_DIR = Path("/etc/NetworkManager/system-connections")
DNSMASQ_FILE = Path("/root/config/dnsmasq.conf")
SHADOW_FILE = Path("/etc/shadow")
SSHD_CONFIG_FILE = Path("/etc/ssh/sshd_config")

def backup_file(path: Path):
    if path.exists():
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        bak_path = path.with_suffix(path.suffix + f".{timestamp}.bak")
        shutil.copy2(path, bak_path)
        print(f"Backup created: {bak_path}")

class JackConf:
    def __init__(self, config_path=CONFIG_FILE):
        self.config = toml.load(config_path)

    def gen_nmconnection(self, name, iface, ipv4_addr=None, dns=None, method="manual"):
        uid = str(uuid.uuid4())
        lines = [
            "[connection]",
            f"id={name}",
            f"uuid={uid}",
            "type=ethernet",
            "autoconnect=false",
            f"interface-name={iface}",
            "",
            "[ethernet]",
            "",
            "[ipv4]",
        ]
        if ipv4_addr:
            lines.append(f"address1={ipv4_addr}")
            lines.append(f"method={method}")
        else:
            lines.append(f"method={method}")
        if dns:
            lines.append(f"dns={';'.join(dns)};")
        lines.append("")
        lines.append("[ipv6]")
        lines.append("addr-gen-mode=stable-privacy")
        lines.append("method=auto")
        lines.append("")
        lines.append("[proxy]")
        lines.append("")
        return "\n".join(lines)

    def gen_dnsmasq_conf(self, dhcp_server):
        lines = []
        if "listen_address" in dhcp_server:
            lines.append(f"listen-address={dhcp_server['listen_address']}")
        if "dhcp_range" in dhcp_server:
            lines.append(f"dhcp-range={dhcp_server['dhcp_range']}")
        if "dhcp_options" in dhcp_server:
            for opt in dhcp_server["dhcp_options"]:
                key, val = opt
                if val == "":
                    lines.append(f"dhcp-option={key}")
                else:
                    lines.append(f"dhcp-option={key},{val}")
        if "dhcp_hosts" in dhcp_server:
            for hosts in dhcp_server["dhcp_hosts"]:
                lines.append(f"dhcp-host={hosts}")
        return "\n".join(lines)

    def apply_nmconnection(self, name, content, do_apply=True):
        path = NM_DIR / f"{name}.nmconnection"
        if do_apply:
            NM_DIR.mkdir(parents=True, exist_ok=True)
            backup_file(path)
            with open(path, "w") as f:
                f.write(content)
            print(f"Applied {path}")
        else:
            print(f"--- {name}.nmconnection ---\n{content}\n")

    def apply_dnsmasq(self, content, do_apply=True):
        if do_apply:
            backup_file(DNSMASQ_FILE)
            with open(DNSMASQ_FILE, "w") as f:
                f.write(content)
            print(f"Applied {DNSMASQ_FILE}")
        else:
            print(f"--- dnsmasq.conf ---\n{content}\n")

    def apply_shadow(self, shadows, do_apply=True):
        if not SHADOW_FILE.exists():
            print(f"{SHADOW_FILE} not found, skipping shadow update")
            return
        existing = SHADOW_FILE.read_text().splitlines()
        shadow_dict = {line.split(":")[0]: line for line in existing}
        for line in shadows:
            user = line.split(":")[0]
            shadow_dict[user] = line
        content = "\n".join(shadow_dict.values()) + "\n"
        if do_apply:
            backup_file(SHADOW_FILE)
            with open(SHADOW_FILE, "w") as f:
                f.write(content)
            print(f"Applied {SHADOW_FILE}")
        else:
            print(f"--- /etc/shadow ---\n{content}\n")

    def apply_sshd(self, root_login, do_apply=True):
        lines = []
        if SSHD_CONFIG_FILE.exists():
            lines = SSHD_CONFIG_FILE.read_text().splitlines()
        new_lines = []
        found = False
        for line in lines:
            if line.strip().startswith("PermitRootLogin"):
                new_lines.append(f"PermitRootLogin {root_login}")
                found = True
            else:
                new_lines.append(line)
        if not found:
            new_lines.append(f"PermitRootLogin {root_login}")
        content = "\n".join(new_lines) + "\n"
        if do_apply:
            backup_file(SSHD_CONFIG_FILE)
            with open(SSHD_CONFIG_FILE, "w") as f:
                f.write(content)
            print(f"Applied {SSHD_CONFIG_FILE}")
        else:
            print(f"--- sshd_config ---\n{content}\n")

    def apply_authorized_keys(self, allow_hosts, do_apply=True):
        for entry in allow_hosts:
            if len(entry) != 2:
                continue
            user, key = entry
            try:
                import pwd
                pw = pwd.getpwnam(user)
                home = Path(pw.pw_dir)
            except KeyError:
                print(f"User {user} not found, skipping authorized_keys")
                continue

            ssh_dir = home / ".ssh"
            auth_file = ssh_dir / "authorized_keys"

            if do_apply:
                ssh_dir.mkdir(mode=0o700, exist_ok=True)
                existing_keys = []
                if auth_file.exists():
                    existing_keys = auth_file.read_text().splitlines()
                if key not in existing_keys:
                    with open(auth_file, "a") as f:
                        f.write(key + "\n")
                    auth_file.chmod(0o600)
                    os.chown(auth_file, pw.pw_uid, pw.pw_gid)
                    os.chown(ssh_dir, pw.pw_uid, pw.pw_gid)
                    print(f"Added key for {user} in {auth_file}")
            else:
                print(f"--- {user} authorized_keys ---")
                print(key)
                print("")

    def dump(self):
        self.apply_all(do_apply=False)

    def apply_all(self, do_apply=True):
        network = self.config.get("network", {})
        auth = self.config.get("authentication", {})

        # Static
        static = network.get("end0", {}).get("static", {})
        if static:
            content = self.gen_nmconnection(
                "static",
                "end0",
                ipv4_addr=static.get("ipv4_addr"),
                method="manual"
            )
            self.apply_nmconnection("static", content, do_apply)

        # DHCP Server
        dhcp_server = network.get("end0", {}).get("dhcp_server", {})
        if dhcp_server:
            content = self.gen_nmconnection(
                "dhcp-server",
                "end0",
                ipv4_addr=dhcp_server.get("ipv4_addr"),
                method="manual"
            )
            self.apply_nmconnection("dhcp-server", content, do_apply)
            dnsmasq_content = self.gen_dnsmasq_conf(dhcp_server)
            self.apply_dnsmasq(dnsmasq_content, do_apply)

        # DHCP Client
        dhcp_client = network.get("end0", {}).get("dhcp_client", {})
        if dhcp_client:
            content = self.gen_nmconnection(
                "dhcp-client",
                "end0",
                dns=dhcp_client.get("dns_servers"),
                method="auto"
            )
            self.apply_nmconnection("dhcp-client", content, do_apply)

        # Authentication
        shadows = auth.get("shadow", [])
        if shadows:
            self.apply_shadow(shadows, do_apply)

        ssh_root = auth.get("ssh", {}).get("root_login")
        if ssh_root:
            self.apply_sshd(ssh_root, do_apply)

        allow_hosts = auth.get("ssh", {}).get("allow_hosts", [])
        if allow_hosts:
            self.apply_authorized_keys(allow_hosts, do_apply)

def main():
    parser = argparse.ArgumentParser(description="LicheeJack configuration tool")
    parser.add_argument("command", choices=["dump", "apply"], help="Command to run")
    args = parser.parse_args()

    jc = JackConf()
    if args.command == "dump":
        jc.dump()
    elif args.command == "apply":
        jc.apply_all(do_apply=True)


if __name__ == "__main__":
    main()
